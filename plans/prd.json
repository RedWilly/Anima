[
  {
    "category": "Core - Math Utilities",
    "description": "Vector2 class implements basic vector operations",
    "steps": [
      "Create Vector2 with x, y values",
      "Verify add() returns correct sum vector",
      "Verify subtract() returns correct difference vector",
      "Verify multiply(scalar) scales correctly",
      "Verify dot() returns correct dot product",
      "Verify length() returns correct magnitude",
      "Verify normalize() returns unit vector",
      "Verify lerp(other, t) interpolates correctly"
    ],
    "passes": true
  },
  {
    "category": "Core - Math Utilities",
    "description": "Vector2 static constants are defined correctly",
    "steps": [
      "Verify Vector2.ZERO equals (0, 0)",
      "Verify Vector2.UP equals (0, -1)",
      "Verify Vector2.DOWN equals (0, 1)",
      "Verify Vector2.LEFT equals (-1, 0)",
      "Verify Vector2.RIGHT equals (1, 0)"
    ],
    "passes": true
  },
  {
    "category": "Core - Math Utilities",
    "description": "Matrix3x3 implements affine transformations",
    "steps": [
      "Create Matrix3x3 with 9 values (row-major)",
      "Verify multiply() composes matrices correctly",
      "Verify transformPoint() applies transformation to Vector2",
      "Verify inverse() returns correct inverse matrix",
      "Verify identity() returns identity matrix"
    ],
    "passes": true
  },
  {
    "category": "Core - Math Utilities",
    "description": "Matrix3x3 static factories create correct matrices",
    "steps": [
      "Verify Matrix3x3.translation(tx, ty) creates translation matrix",
      "Verify Matrix3x3.rotation(angle) creates rotation matrix",
      "Verify Matrix3x3.scale(sx, sy) creates scale matrix",
      "Verify Matrix3x3.shear(shx, shy) creates shear matrix"
    ],
    "passes": true
  },
  {
    "category": "Core - Math Utilities",
    "description": "Color class handles color operations",
    "steps": [
      "Create Color with r, g, b, a values",
      "Verify Color.fromHex() parses hex strings correctly",
      "Verify Color.fromHSL() converts HSL to RGB",
      "Verify toHex() returns correct hex string",
      "Verify toRGBA() returns correct rgba string",
      "Verify lerp() interpolates between colors"
    ],
    "passes": true
  },
  {
    "category": "Core - Math Utilities",
    "description": "Color predefined constants are available",
    "steps": [
      "Verify Color.WHITE is (255, 255, 255)",
      "Verify Color.BLACK is (0, 0, 0)",
      "Verify Color.RED is (255, 0, 0)",
      "Verify Color.GREEN is (0, 255, 0)",
      "Verify Color.BLUE is (0, 0, 255)"
    ],
    "passes": true
  },
  {
    "category": "Core - BezierPath",
    "description": "BezierPath supports path construction",
    "steps": [
      "Create BezierPath and call moveTo(point)",
      "Verify lineTo(point) adds line segment",
      "Verify quadraticTo(control, end) adds quadratic curve",
      "Verify cubicTo(c1, c2, end) adds cubic curve",
      "Verify closePath() closes the path"
    ],
    "passes": true
  },
  {
    "category": "Core - BezierPath",
    "description": "BezierPath provides path analysis methods",
    "steps": [
      "Create a BezierPath with multiple segments",
      "Verify getPointAt(0) returns start point",
      "Verify getPointAt(1) returns end point",
      "Verify getPointAt(0.5) returns midpoint",
      "Verify getTangentAt(t) returns tangent vector",
      "Verify getLength() returns path length"
    ],
    "passes": true
  },
  {
    "category": "Core - BezierPath",
    "description": "BezierPath supports morphing operations",
    "steps": [
      "Create two BezierPaths",
      "Verify getPoints(n) returns n evenly spaced points",
      "Verify getPointCount() returns correct count",
      "Verify BezierPath.interpolate(p1, p2, 0) equals p1",
      "Verify BezierPath.interpolate(p1, p2, 1) equals p2",
      "Verify BezierPath.matchPoints() handles different point counts"
    ],
    "passes": true
  },
  {
    "category": "Mobjects - Base Classes",
    "description": "Mobject base class has correct default state",
    "steps": [
      "Create a new Mobject subclass instance",
      "Verify default position is (0, 0)",
      "Verify default rotation is 0",
      "Verify default scale is (1, 1)",
      "Verify default opacity is 0 (invisible by default)"
    ],
    "passes": true
  },
  {
    "category": "Mobjects - Base Classes",
    "description": "Mobject immediate state setters work correctly",
    "steps": [
      "Create a Mobject",
      "Call pos(x, y) and verify position changes",
      "Call show() and verify opacity becomes 1",
      "Call hide() and verify opacity becomes 0"
    ],
    "passes": true
  },
  {
    "category": "Mobjects - Base Classes",
    "description": "Mobject supports Matrix3x3 transformations",
    "steps": [
      "Create a Mobject at position (10, 20)",
      "Apply translation matrix",
      "Verify position is transformed correctly",
      "Apply rotation matrix",
      "Verify rotation is applied correctly"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - VMobject",
    "description": "VMobject extends Mobject with vector graphics",
    "steps": [
      "Create a VMobject",
      "Verify it has paths array",
      "Verify it has style (strokeColor, strokeWidth, fillColor, fillOpacity)",
      "Call stroke(color, width) and verify style updates",
      "Call fill(color, opacity) and verify style updates"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - VMobject",
    "description": "VMobject path manipulation works correctly",
    "steps": [
      "Create a VMobject with BezierPath",
      "Call getPoints() and verify points returned",
      "Call setPoints(newPoints)",
      "Verify getPoints() returns the new points"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Primitives",
    "description": "Circle primitive creates correct shape",
    "steps": [
      "Create Circle with default radius",
      "Verify Circle has circular BezierPath",
      "Create Circle with custom radius",
      "Verify radius affects path size"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Primitives",
    "description": "Rectangle primitive creates correct shape",
    "steps": [
      "Create Rectangle with default dimensions",
      "Verify Rectangle has rectangular BezierPath",
      "Create Rectangle with custom width and height",
      "Verify dimensions affect path size"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Primitives",
    "description": "Line primitive creates correct shape",
    "steps": [
      "Create Line with start and end points",
      "Verify Line has straight BezierPath",
      "Verify getPointAt(0) equals start",
      "Verify getPointAt(1) equals end"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Primitives",
    "description": "Arrow primitive extends Line with arrowhead",
    "steps": [
      "Create Arrow with start and end points",
      "Verify Arrow has line segment",
      "Verify Arrow has arrowhead at end"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Primitives",
    "description": "Arc primitive creates correct arc shape",
    "steps": [
      "Create Arc with radius, startAngle, endAngle",
      "Verify Arc has curved BezierPath",
      "Verify arc spans correct angle range"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Primitives",
    "description": "Polygon primitive creates correct shape",
    "steps": [
      "Create Polygon with vertices",
      "Verify Polygon has closed BezierPath",
      "Verify all vertices are connected"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Primitives",
    "description": "Point primitive creates small circle",
    "steps": [
      "Create Point with position",
      "Verify Point has small circular representation",
      "Verify Point position is correct"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - VGroup",
    "description": "VGroup collects and manages VMobjects",
    "steps": [
      "Create VGroup with multiple VMobjects",
      "Verify getChildren() returns all children",
      "Call add(mobject) and verify child is added",
      "Call remove(mobject) and verify child is removed",
      "Verify get(index) returns correct child"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - VGroup",
    "description": "VGroup transformations propagate to children",
    "steps": [
      "Create VGroup with children",
      "Apply moveTo transformation to VGroup",
      "Verify all children positions are updated",
      "Apply rotate transformation to VGroup",
      "Verify all children rotations are updated",
      "Apply scale transformation to VGroup",
      "Verify all children scales are updated"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - VGroup",
    "description": "VGroup supports nested VGroups",
    "steps": [
      "Create nested VGroup structure (VGroup containing VGroups)",
      "Apply transformation to parent VGroup",
      "Verify transformation propagates to all descendants recursively"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - VGroup",
    "description": "VGroup child independence is maintained",
    "steps": [
      "Create VGroup with children",
      "Modify individual child properties",
      "Verify child remains in group",
      "Verify other children are unaffected"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - VGroup Arrange",
    "description": "VGroup arrange() positions children correctly",
    "steps": [
      "Create VGroup with multiple children",
      "Call arrange('RIGHT', spacing)",
      "Verify children are positioned horizontally with spacing",
      "Call arrange('DOWN', spacing)",
      "Verify children are positioned vertically with spacing"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - VGroup Arrange",
    "description": "VGroup alignTo() aligns to target edge",
    "steps": [
      "Create VGroup and target VMobject",
      "Call alignTo(target, 'TOP')",
      "Verify VGroup top edge aligns with target top",
      "Call alignTo(target, 'LEFT')",
      "Verify VGroup left edge aligns with target left"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - VGroup Arrange",
    "description": "VGroup center() and toCorner() work correctly",
    "steps": [
      "Create VGroup",
      "Call center()",
      "Verify VGroup is centered at (0, 0)",
      "Call toCorner('TOP_LEFT')",
      "Verify VGroup is positioned at top-left corner"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Text",
    "description": "Text creates vectorized glyphs using fontkit",
    "steps": [
      "Create Text with string content",
      "Verify Text is a VGroup",
      "Verify each character becomes a VMobject glyph",
      "Verify getChildren() returns glyph VMobjects",
      "Verify get(index) returns specific glyph"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Text",
    "description": "Text styling works correctly",
    "steps": [
      "Create Text with custom style (fontFamily, fontSize, color)",
      "Verify style is applied to all glyphs",
      "Call setStyle() to change style",
      "Verify new style is applied"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Text",
    "description": "Text supports per-glyph animation",
    "steps": [
      "Create Text with multiple characters",
      "Access individual glyph via get(0)",
      "Apply animation to single glyph",
      "Verify only that glyph is animated"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Graph",
    "description": "Graph manages nodes and edges",
    "steps": [
      "Create Graph with nodes and edges",
      "Verify addNode() adds node",
      "Verify removeNode() removes node",
      "Verify getNode() returns correct node VMobject",
      "Verify addEdge() connects nodes",
      "Verify removeEdge() removes connection",
      "Verify getEdgePath() returns BezierPath"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Graph",
    "description": "Graph nodes are VMobjects with styling",
    "steps": [
      "Create Graph with styled nodes",
      "Verify node inherits VMobject styling",
      "Apply stroke and fill to node",
      "Verify styling is applied"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Graph",
    "description": "Graph edges are BezierPath curves",
    "steps": [
      "Create Graph with edges",
      "Verify edges are BezierPath curves",
      "Verify edges can be styled independently",
      "Verify edges support smooth animations"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Graph Layout",
    "description": "Graph layout algorithms reposition nodes",
    "steps": [
      "Create Graph with multiple nodes",
      "Call layout('force-directed')",
      "Verify nodes are repositioned",
      "Call layout('tree')",
      "Verify tree layout is applied",
      "Call layout('circular')",
      "Verify circular layout is applied"
    ],
    "passes": false
  },
  {
    "category": "Animations - Easing",
    "description": "Built-in easing functions work correctly",
    "steps": [
      "Verify Easing.linear(0) = 0 and Easing.linear(1) = 1",
      "Verify Easing.easeIn(0) = 0 and Easing.easeIn(1) = 1",
      "Verify Easing.easeOut(0) = 0 and Easing.easeOut(1) = 1",
      "Verify Easing.easeInOut(0) = 0 and Easing.easeInOut(1) = 1",
      "Verify Easing.bounce(0) = 0 and Easing.bounce(1) = 1",
      "Verify Easing.elastic(0) = 0 and Easing.elastic(1) = 1"
    ],
    "passes": false
  },
  {
    "category": "Animations - Easing",
    "description": "Custom easing functions can be registered",
    "steps": [
      "Define custom easing function (t) => t",
      "Call registerEasing('custom', fn)",
      "Verify custom easing can be used in animations"
    ],
    "passes": false
  },
  {
    "category": "Animations - Base",
    "description": "Animation base class configures correctly",
    "steps": [
      "Create Animation with target Mobject",
      "Verify default duration is applied",
      "Call duration(2) and verify duration changes",
      "Call ease(Easing.easeIn) and verify easing changes",
      "Call delay(0.5) and verify delay is set"
    ],
    "passes": false
  },
  {
    "category": "Animations - FadeIn/FadeOut",
    "description": "FadeIn animation increases opacity",
    "steps": [
      "Create Mobject with opacity 0",
      "Apply FadeIn animation",
      "Verify interpolate(0) keeps opacity at 0",
      "Verify interpolate(0.5) sets opacity to 0.5",
      "Verify interpolate(1) sets opacity to 1"
    ],
    "passes": false
  },
  {
    "category": "Animations - FadeIn/FadeOut",
    "description": "FadeOut animation decreases opacity",
    "steps": [
      "Create Mobject with opacity 1",
      "Apply FadeOut animation",
      "Verify interpolate(0) keeps opacity at 1",
      "Verify interpolate(0.5) sets opacity to 0.5",
      "Verify interpolate(1) sets opacity to 0"
    ],
    "passes": false
  },
  {
    "category": "Animations - MoveTo",
    "description": "MoveTo animation moves Mobject to destination",
    "steps": [
      "Create Mobject at position (0, 0)",
      "Apply MoveTo animation to (100, 50)",
      "Verify interpolate(0) keeps position at (0, 0)",
      "Verify interpolate(0.5) sets position to (50, 25)",
      "Verify interpolate(1) sets position to (100, 50)"
    ],
    "passes": false
  },
  {
    "category": "Animations - Rotate",
    "description": "Rotate animation rotates Mobject",
    "steps": [
      "Create Mobject with rotation 0",
      "Apply Rotate animation by 90 degrees",
      "Verify interpolate(0) keeps rotation at 0",
      "Verify interpolate(0.5) sets rotation to 45",
      "Verify interpolate(1) sets rotation to 90"
    ],
    "passes": false
  },
  {
    "category": "Animations - Scale",
    "description": "Scale animation scales Mobject",
    "steps": [
      "Create Mobject with scale (1, 1)",
      "Apply Scale animation to factor 2",
      "Verify interpolate(0) keeps scale at (1, 1)",
      "Verify interpolate(0.5) sets scale to (1.5, 1.5)",
      "Verify interpolate(1) sets scale to (2, 2)"
    ],
    "passes": false
  },
  {
    "category": "Animations - MorphTo",
    "description": "MorphTo animation morphs between VMobjects",
    "steps": [
      "Create source VMobject (Circle)",
      "Create target VMobject (Rectangle)",
      "Apply MorphTo animation",
      "Verify interpolate(0) shows source shape",
      "Verify interpolate(0.5) shows intermediate shape",
      "Verify interpolate(1) shows target shape"
    ],
    "passes": false
  },
  {
    "category": "Animations - Create",
    "description": "Create animation draws VMobject progressively",
    "steps": [
      "Create VMobject",
      "Apply Create animation",
      "Verify interpolate(0) shows nothing",
      "Verify interpolate(0.5) shows partial path",
      "Verify interpolate(1) shows complete path"
    ],
    "passes": false
  },
  {
    "category": "Animations - Draw",
    "description": "Draw animation draws border then fills",
    "steps": [
      "Create VMobject with stroke and fill",
      "Apply draw() animation",
      "Verify first half draws border progressively",
      "Verify second half fills shape",
      "Verify animation completes with full shape visible"
    ],
    "passes": false
  },
  {
    "category": "Animations - Write",
    "description": "Write animation simulates hand-writing",
    "steps": [
      "Create VMobject or Text",
      "Apply write() animation",
      "Verify stroke is drawn progressively from start to end",
      "Verify animation simulates natural writing motion",
      "Verify interpolate(0) shows nothing",
      "Verify interpolate(0.5) shows half the stroke",
      "Verify interpolate(1) shows complete stroke"
    ],
    "passes": false
  },
  {
    "category": "Animations - Unwrite",
    "description": "Unwrite animation simulates erasing",
    "steps": [
      "Create VMobject or Text with visible stroke",
      "Apply unwrite() animation",
      "Verify stroke is removed progressively in reverse",
      "Verify animation simulates natural erasing motion",
      "Verify interpolate(0) shows full stroke",
      "Verify interpolate(0.5) shows half the stroke",
      "Verify interpolate(1) shows nothing"
    ],
    "passes": false
  },
  {
    "category": "Animations - Sequence",
    "description": "Sequence executes animations in order",
    "steps": [
      "Create Sequence with animations A, B, C",
      "Verify A starts at time 0",
      "Verify B starts after A completes",
      "Verify C starts after B completes",
      "Verify total duration is sum of all durations"
    ],
    "passes": false
  },
  {
    "category": "Animations - Parallel",
    "description": "Parallel executes animations simultaneously",
    "steps": [
      "Create Parallel with animations A, B, C",
      "Verify all animations start at time 0",
      "Verify all animations run concurrently",
      "Verify total duration is max of all durations"
    ],
    "passes": false
  },
  {
    "category": "Animations - Keyframes",
    "description": "KeyframeTrack manages keyframes correctly",
    "steps": [
      "Create KeyframeTrack",
      "Add keyframe at time 0 with value A",
      "Add keyframe at time 1 with value B",
      "Verify getValueAt(0) returns A",
      "Verify getValueAt(1) returns B",
      "Verify getValueAt(0.5) returns interpolated value"
    ],
    "passes": false
  },
  {
    "category": "Animations - Keyframes",
    "description": "KeyframeAnimation supports multiple tracks",
    "steps": [
      "Create KeyframeAnimation",
      "Add position track with keyframes",
      "Add opacity track with keyframes",
      "Verify both tracks interpolate correctly during playback"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI methods return this for chaining",
    "steps": [
      "Create Mobject",
      "Call fadeIn() and verify returns same instance",
      "Call moveTo() and verify returns same instance",
      "Call rotate() and verify returns same instance",
      "Call scaleTo() and verify returns same instance",
      "Chain multiple methods: mobject.fadeIn().moveTo(x,y).rotate(45)"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI uses default 1 second duration",
    "steps": [
      "Create Mobject",
      "Call fadeIn() without duration argument",
      "Verify animation duration is 1 second",
      "Call moveTo(x, y) without duration",
      "Verify animation duration is 1 second"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI supports inline optional duration parameter",
    "steps": [
      "Create Mobject",
      "Call fadeIn(2) with inline duration",
      "Verify animation duration is 2 seconds",
      "Call moveTo(100, 50, 1.5) with inline duration",
      "Verify animation duration is 1.5 seconds",
      "Call rotate(90, 0.5) with inline duration",
      "Verify animation duration is 0.5 seconds",
      "Call scaleTo(2, 3) with inline duration",
      "Verify animation duration is 3 seconds"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI inline duration and .duration() method are equivalent",
    "steps": [
      "Create Mobject",
      "Call fadeIn(2) with inline duration",
      "Create another Mobject",
      "Call fadeIn().duration(2) with method",
      "Verify both produce same animation duration",
      "Verify both produce same visual result"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI duration() and ease() modifiers work",
    "steps": [
      "Create Mobject",
      "Call fadeIn().duration(2)",
      "Verify animation duration is 2 seconds",
      "Call moveTo(x, y).ease(Easing.easeIn)",
      "Verify easing function is applied"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI write() and unwrite() support optional duration",
    "steps": [
      "Create Text",
      "Call write(2) with inline duration",
      "Verify animation duration is 2 seconds",
      "Call write().duration(3) with method",
      "Verify animation duration is 3 seconds",
      "Call unwrite(1.5) with inline duration",
      "Verify animation duration is 1.5 seconds"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI draw() and create() support optional duration",
    "steps": [
      "Create VMobject",
      "Call create(2) with inline duration",
      "Verify animation duration is 2 seconds",
      "Call draw(1.5) with inline duration",
      "Verify animation duration is 1.5 seconds",
      "Call create().duration(3) with method",
      "Verify animation duration is 3 seconds"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI chained animations execute sequentially",
    "steps": [
      "Create Mobject",
      "Chain: fadeIn().moveTo(100, 0).rotate(90)",
      "Verify fadeIn starts first",
      "Verify moveTo starts after fadeIn completes",
      "Verify rotate starts after moveTo completes"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI toAnimation() converts to ProAPI Animation",
    "steps": [
      "Create Mobject with fluent chain",
      "Call toAnimation()",
      "Verify returned Animation has same duration",
      "Verify returned Animation has same easing",
      "Verify returned Animation produces same result"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI - VGroup",
    "description": "FluentAPI works recursively on VGroups",
    "steps": [
      "Create VGroup with children",
      "Call vgroup.fadeIn()",
      "Verify all children fade in together",
      "Call vgroup.moveTo(x, y)",
      "Verify all children move together"
    ],
    "passes": false
  },
  {
    "category": "ProAPI",
    "description": "ProAPI exposes Animation objects for composition",
    "steps": [
      "Create Animation object directly",
      "Configure duration, easing, delay explicitly",
      "Verify Animation can be scheduled on Timeline"
    ],
    "passes": false
  },
  {
    "category": "ProAPI",
    "description": "ProAPI provides raw keyframe manipulation",
    "steps": [
      "Create KeyframeTrack",
      "Add keyframes at specific times",
      "Modify keyframe values",
      "Remove keyframes",
      "Verify keyframe changes affect animation"
    ],
    "passes": false
  },
  {
    "category": "ProAPI",
    "description": "ProAPI Sequence and Parallel containers work",
    "steps": [
      "Create Sequence with multiple Animations",
      "Verify sequential execution",
      "Create Parallel with multiple Animations",
      "Verify simultaneous execution"
    ],
    "passes": false
  },
  {
    "category": "ProAPI",
    "description": "ProAPI supports custom Mobject subclasses",
    "steps": [
      "Create custom class extending VMobject",
      "Implement custom render method",
      "Add custom Mobject to Scene",
      "Verify custom Mobject renders correctly"
    ],
    "passes": false
  },
  {
    "category": "Hybrid API",
    "description": "FluentAPI and ProAPI produce consistent results",
    "steps": [
      "Create animation using FluentAPI",
      "Create equivalent animation using ProAPI",
      "Render both animations",
      "Verify visual output is identical"
    ],
    "passes": false
  },
  {
    "category": "Hybrid API",
    "description": "FluentAPI chain can be embedded in ProAPI Timeline",
    "steps": [
      "Create FluentAPI chain on Mobject",
      "Convert to Animation via toAnimation()",
      "Schedule on Timeline with explicit start time",
      "Verify animation starts at specified time"
    ],
    "passes": false
  },
  {
    "category": "Hybrid API",
    "description": "Mixing APIs in same animation works",
    "steps": [
      "Create Scene",
      "Use FluentAPI for some Mobjects",
      "Use ProAPI for other Mobjects",
      "Verify all animations render correctly together"
    ],
    "passes": false
  },
  {
    "category": "Timeline",
    "description": "Timeline schedules animations correctly",
    "steps": [
      "Create Timeline",
      "Schedule animation at time 0",
      "Schedule animation at time 2",
      "Verify animations start at correct times",
      "Verify getTotalDuration() returns correct value"
    ],
    "passes": false
  },
  {
    "category": "Timeline",
    "description": "Timeline scheduleSequence works",
    "steps": [
      "Create Timeline",
      "Call scheduleSequence(A, B, C)",
      "Verify A starts at time 0",
      "Verify B starts after A",
      "Verify C starts after B"
    ],
    "passes": false
  },
  {
    "category": "Timeline",
    "description": "Timeline scheduleParallel works",
    "steps": [
      "Create Timeline",
      "Call scheduleParallel(A, B, C)",
      "Verify all animations start at same time"
    ],
    "passes": false
  },
  {
    "category": "Timeline",
    "description": "Timeline seek() jumps to time",
    "steps": [
      "Create Timeline with animations",
      "Call seek(0)",
      "Verify state is at beginning",
      "Call seek(totalDuration)",
      "Verify state is at end"
    ],
    "passes": false
  },
  {
    "category": "Timeline",
    "description": "Timeline getStateAt() returns correct state",
    "steps": [
      "Create Timeline with animations",
      "Call getStateAt(0)",
      "Verify initial state returned",
      "Call getStateAt(midpoint)",
      "Verify intermediate state returned"
    ],
    "passes": false
  },
  {
    "category": "Timeline",
    "description": "Timeline handles animation delays",
    "steps": [
      "Create Animation with delay(1)",
      "Schedule on Timeline",
      "Verify animation starts 1 second after scheduled time"
    ],
    "passes": false
  },
  {
    "category": "Timeline",
    "description": "Timeline blends overlapping animations",
    "steps": [
      "Create two animations affecting same property",
      "Schedule them to overlap in time",
      "Verify additive blending is applied",
      "Verify result is blend of both animations"
    ],
    "passes": false
  },
  {
    "category": "Scene",
    "description": "Scene configuration is preserved",
    "steps": [
      "Create Scene with custom width, height, backgroundColor",
      "Verify Scene has correct dimensions",
      "Verify Scene has correct background color",
      "Verify Scene has correct frame rate"
    ],
    "passes": false
  },
  {
    "category": "Scene",
    "description": "Scene tracks added Mobjects",
    "steps": [
      "Create Scene",
      "Call add(mobject1, mobject2)",
      "Verify mobjects are tracked in Scene",
      "Call remove(mobject1)",
      "Verify mobject1 is removed"
    ],
    "passes": false
  },
  {
    "category": "Scene",
    "description": "Scene play() schedules animations",
    "steps": [
      "Create Scene with Mobjects",
      "Call play(animation1, animation2)",
      "Verify animations are scheduled on Timeline"
    ],
    "passes": false
  },
  {
    "category": "Scene",
    "description": "Scene wait() adds delay",
    "steps": [
      "Create Scene",
      "Call play(animation)",
      "Call wait(2)",
      "Verify 2 second gap before next animation"
    ],
    "passes": false
  },
  {
    "category": "Scene",
    "description": "Scene provides ProAPI access",
    "steps": [
      "Create Scene",
      "Call getTimeline()",
      "Verify Timeline is returned",
      "Call getCamera()",
      "Verify Camera is returned"
    ],
    "passes": false
  },
  {
    "category": "Scene",
    "description": "Scene supports multiple Scene classes per file",
    "steps": [
      "Create file with multiple Scene subclasses",
      "Load file with SceneLoader",
      "Verify all Scene classes are discovered",
      "Verify each Scene can be instantiated"
    ],
    "passes": false
  },
  {
    "category": "Scene",
    "description": "Mobjects added to Scene are invisible by default",
    "steps": [
      "Create Scene",
      "Create Mobject",
      "Call scene.add(mobject)",
      "Verify mobject opacity is 0 (invisible)"
    ],
    "passes": false
  },
  {
    "category": "Camera",
    "description": "Camera pan operations work correctly",
    "steps": [
      "Create Camera at position (0, 0)",
      "Call pan(delta)",
      "Verify position changes by delta",
      "Call panTo(position)",
      "Verify position is set to target"
    ],
    "passes": false
  },
  {
    "category": "Camera",
    "description": "Camera zoom operations work correctly",
    "steps": [
      "Create Camera with zoom 1",
      "Call zoomTo(2)",
      "Verify zoom level is 2",
      "Verify view is magnified"
    ],
    "passes": false
  },
  {
    "category": "Camera",
    "description": "Camera rotation works correctly",
    "steps": [
      "Create Camera with rotation 0",
      "Call rotateTo(45)",
      "Verify rotation is 45 degrees"
    ],
    "passes": false
  },
  {
    "category": "Camera",
    "description": "Camera follow mode tracks Mobject",
    "steps": [
      "Create Camera and Mobject",
      "Call follow(mobject)",
      "Move Mobject to new position",
      "Verify Camera position follows Mobject"
    ],
    "passes": false
  },
  {
    "category": "Camera",
    "description": "Camera uses same easing system as Mobjects",
    "steps": [
      "Create Camera animation with easing",
      "Verify easing function is applied",
      "Verify smooth transition occurs"
    ],
    "passes": false
  },
  {
    "category": "Camera",
    "description": "Camera zoomToFit frames target correctly",
    "steps": [
      "Create Camera and VGroup",
      "Call zoomToFit(vgroup)",
      "Verify Camera zoom and position frame the VGroup"
    ],
    "passes": false
  },
  {
    "category": "Camera",
    "description": "Camera autoCenter centers on target",
    "steps": [
      "Create Camera and Mobject at (100, 50)",
      "Call autoCenter(mobject)",
      "Verify Camera centers on Mobject position"
    ],
    "passes": false
  },
  {
    "category": "Camera",
    "description": "Camera getViewMatrix returns correct matrix",
    "steps": [
      "Create Camera with pan, zoom, rotation",
      "Call getViewMatrix()",
      "Verify Matrix3x3 combines all transformations correctly"
    ],
    "passes": false
  },
  {
    "category": "Serialization",
    "description": "Scene serializes to valid JSON",
    "steps": [
      "Create Scene with Mobjects and animations",
      "Call serialize(scene)",
      "Verify output is valid JSON string",
      "Verify JSON can be parsed"
    ],
    "passes": false
  },
  {
    "category": "Serialization",
    "description": "Serialization preserves all properties",
    "steps": [
      "Create Scene with Mobjects, animations, BezierPaths",
      "Serialize the Scene",
      "Verify all Mobject properties are in JSON",
      "Verify all animation definitions are in JSON",
      "Verify BezierPath control points are preserved"
    ],
    "passes": false
  },
  {
    "category": "Serialization",
    "description": "Deserialization reconstructs Scene exactly",
    "steps": [
      "Create Scene with complex content",
      "Serialize to JSON",
      "Deserialize back to Scene",
      "Verify reconstructed Scene matches original"
    ],
    "passes": false
  },
  {
    "category": "Serialization",
    "description": "Round-trip serialization is lossless",
    "steps": [
      "Create Scene",
      "Serialize then deserialize",
      "Serialize again",
      "Verify both JSON outputs are identical"
    ],
    "passes": false
  },
  {
    "category": "Serialization",
    "description": "Pretty printer produces readable output",
    "steps": [
      "Create Scene",
      "Call prettyPrint(scene)",
      "Verify output is formatted with indentation",
      "Verify output is human-readable"
    ],
    "passes": false
  },
  {
    "category": "Serialization",
    "description": "Custom serializer hooks work for user VMobjects",
    "steps": [
      "Create custom VMobject subclass",
      "Register custom serializer",
      "Serialize Scene with custom VMobject",
      "Deserialize and verify custom VMobject is restored"
    ],
    "passes": false
  },
  {
    "category": "Renderer",
    "description": "Renderer supports multiple resolutions",
    "steps": [
      "Create Renderer with 480p config",
      "Verify output is 854x480",
      "Create Renderer with 720p config",
      "Verify output is 1280x720",
      "Create Renderer with 1080p config",
      "Verify output is 1920x1080",
      "Create Renderer with 4K config",
      "Verify output is 3840x2160"
    ],
    "passes": false
  },
  {
    "category": "Renderer",
    "description": "Renderer supports multiple frame rates",
    "steps": [
      "Create Renderer with 24 FPS",
      "Verify frames are generated at 24 FPS",
      "Create Renderer with 30 FPS",
      "Verify frames are generated at 30 FPS",
      "Create Renderer with 60 FPS",
      "Verify frames are generated at 60 FPS"
    ],
    "passes": false
  },
  {
    "category": "Renderer",
    "description": "Renderer displays progress indication",
    "steps": [
      "Start rendering Scene",
      "Verify onProgress callback is called",
      "Verify progress includes currentFrame, totalFrames",
      "Verify progress includes percentage",
      "Verify progress includes estimatedTimeRemaining"
    ],
    "passes": false
  },
  {
    "category": "Renderer",
    "description": "Renderer preview mode uses lower quality",
    "steps": [
      "Create Renderer with quality: 'preview'",
      "Render Scene",
      "Verify rendering is faster than production",
      "Verify output is lower quality"
    ],
    "passes": false
  },
  {
    "category": "Renderer",
    "description": "Renderer exports MP4 format",
    "steps": [
      "Create Scene with animations",
      "Render with format: 'mp4'",
      "Verify output file is valid MP4"
    ],
    "passes": false
  },
  {
    "category": "Renderer",
    "description": "Renderer exports WEBP format",
    "steps": [
      "Create Scene with animations",
      "Render with format: 'webp'",
      "Verify output file is valid animated WEBP"
    ],
    "passes": false
  },
  {
    "category": "Renderer",
    "description": "Renderer exports GIF format",
    "steps": [
      "Create Scene with animations",
      "Render with format: 'gif'",
      "Verify output file is valid animated GIF"
    ],
    "passes": false
  },
  {
    "category": "Renderer",
    "description": "Renderer exports sprite sequence",
    "steps": [
      "Create Scene with animations",
      "Render with format: 'sprite'",
      "Verify PNG files are generated for each frame"
    ],
    "passes": false
  },
  {
    "category": "Renderer",
    "description": "Renderer exports last frame as PNG",
    "steps": [
      "Create Scene with animations",
      "Call renderLastFrame(scene, outputPath)",
      "Verify single PNG file is generated",
      "Verify PNG shows final animation state"
    ],
    "passes": false
  },
  {
    "category": "Renderer",
    "description": "Renderer applies Matrix3x3 transformations correctly",
    "steps": [
      "Create nested VGroup with transformations",
      "Render frame",
      "Verify parent-child transforms are applied in order"
    ],
    "passes": false
  },
  {
    "category": "Renderer",
    "description": "Frames are numbered sequentially",
    "steps": [
      "Render Scene",
      "Verify frame numbers start at 0",
      "Verify frame numbers are sequential with no gaps"
    ],
    "passes": false
  },
  {
    "category": "CLI",
    "description": "CLI render command works with options",
    "steps": [
      "Run 'anima render file.ts'",
      "Verify Scene is rendered",
      "Run with --format mp4",
      "Verify MP4 output",
      "Run with --resolution 1080p",
      "Verify 1080p output",
      "Run with --fps 60",
      "Verify 60 FPS output"
    ],
    "passes": false
  },
  {
    "category": "CLI",
    "description": "CLI preview command works",
    "steps": [
      "Run 'anima preview file.ts'",
      "Verify quick low-quality preview is generated"
    ],
    "passes": false
  },
  {
    "category": "CLI",
    "description": "CLI export-frame command works",
    "steps": [
      "Run 'anima export-frame file.ts --frame 10'",
      "Verify frame 10 is exported as PNG",
      "Run 'anima export-frame file.ts --frame last'",
      "Verify last frame is exported"
    ],
    "passes": false
  },
  {
    "category": "CLI",
    "description": "CLI list-scenes command works",
    "steps": [
      "Create file with multiple Scene classes",
      "Run 'anima list-scenes file.ts'",
      "Verify all Scene class names are listed"
    ],
    "passes": false
  },
  {
    "category": "CLI",
    "description": "CLI --scene argument selects specific Scene",
    "steps": [
      "Create file with Scene1 and Scene2",
      "Run 'anima render file.ts --scene Scene1'",
      "Verify only Scene1 is rendered"
    ],
    "passes": false
  },
  {
    "category": "CLI",
    "description": "CLI prompts when multiple scenes exist",
    "steps": [
      "Create file with multiple Scene classes",
      "Run 'anima render file.ts' without --scene",
      "Verify CLI prompts to select or render all"
    ],
    "passes": false
  },
  {
    "category": "CLI",
    "description": "CLI displays progress and ETA",
    "steps": [
      "Run render command",
      "Verify progress percentage is displayed",
      "Verify estimated time remaining is shown"
    ],
    "passes": false
  },
  {
    "category": "CLI",
    "description": "CLI shows helpful usage on invalid arguments",
    "steps": [
      "Run 'anima render' without file",
      "Verify helpful usage information is displayed",
      "Run with invalid --format",
      "Verify error message explains valid formats"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Invalid Scene config throws descriptive error",
    "steps": [
      "Create Scene with negative width",
      "Verify InvalidSceneConfig error is thrown",
      "Verify error message describes the issue",
      "Verify error suggests correction"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Missing Mobject reference throws error",
    "steps": [
      "Create animation referencing non-existent Mobject",
      "Verify MobjectNotFound error is thrown",
      "Verify error identifies which Mobject is missing"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Invalid animation config throws error",
    "steps": [
      "Create animation with negative duration",
      "Verify InvalidAnimationConfig error is thrown",
      "Verify error describes what is invalid"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Invalid easing function throws error",
    "steps": [
      "Provide easing function with wrong signature",
      "Verify InvalidEasingFunction error is thrown",
      "Verify error shows expected signature"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Invalid Matrix3x3 throws error",
    "steps": [
      "Apply non-invertible matrix",
      "Verify InvalidMatrixTransform error is thrown",
      "Verify error shows matrix values"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "BezierPath point mismatch throws error",
    "steps": [
      "Attempt to morph paths with incompatible point counts",
      "Verify BezierPointMismatch error is thrown",
      "Verify error shows source and target point counts"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Serialization errors are descriptive",
    "steps": [
      "Attempt to serialize non-serializable object",
      "Verify SerializationError is thrown",
      "Verify error indicates which part failed"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Deserialization errors are descriptive",
    "steps": [
      "Attempt to deserialize malformed JSON",
      "Verify DeserializationError is thrown",
      "Verify error indicates location of parse error"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Render errors are descriptive",
    "steps": [
      "Cause rendering to fail",
      "Verify RenderError is thrown",
      "Verify error includes recovery suggestions"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "CLI file not found error is clear",
    "steps": [
      "Run 'anima render nonexistent.ts'",
      "Verify FileNotFound error is shown",
      "Verify error message is helpful"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "CLI scene not found error is clear",
    "steps": [
      "Run 'anima render file.ts --scene NonExistent'",
      "Verify SceneNotFound error is shown",
      "Verify available scenes are listed"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Overlapping animation conflict warning",
    "steps": [
      "Create overlapping animations with conflicting durations",
      "Verify warning is logged about the conflict"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Debug mode shows stack traces",
    "steps": [
      "Enable debug mode",
      "Trigger an error",
      "Verify stack trace is included in output"
    ],
    "passes": false
  },
  {
    "category": "Public API",
    "description": "Public API exports only required interfaces",
    "steps": [
      "Import from 'anima'",
      "Verify Scene is exported",
      "Verify Mobject, VMobject, VGroup are exported",
      "Verify primitives (Circle, Rectangle, etc.) are exported",
      "Verify Animation, Sequence, Parallel are exported",
      "Verify Easing, Color, Vector2, Matrix3x3 are exported",
      "Verify internal implementation details are NOT exported"
    ],
    "passes": false
  },
  {
    "category": "Public API",
    "description": "Internal modules are hidden from users",
    "steps": [
      "Attempt to import internal modules",
      "Verify internal modules are not accessible",
      "Verify only public API is exposed"
    ],
    "passes": false
  },
  {
    "category": "Modular Architecture",
    "description": "Code is organized into distinct modules",
    "steps": [
      "Verify src/core/ contains Scene, Timeline, Camera",
      "Verify src/mobjects/ contains Mobject, VMobject, VGroup, primitives",
      "Verify src/animations/ contains Animation classes",
      "Verify src/timeline/ contains Timeline logic",
      "Verify src/renderer/ contains Renderer",
      "Verify src/cli/ contains CLI commands"
    ],
    "passes": false
  },
  {
    "category": "Modular Architecture",
    "description": "Modules have clear interfaces",
    "steps": [
      "Verify each module exports defined interfaces",
      "Verify modules can be extended via interfaces",
      "Verify extending engine only requires implementing interfaces"
    ],
    "passes": false
  },
  {
    "category": "Integration",
    "description": "Full animation renders end-to-end",
    "steps": [
      "Create Scene with multiple Mobjects",
      "Add various animations (fade, move, rotate, morph)",
      "Use both FluentAPI and ProAPI",
      "Render to MP4",
      "Verify output video plays correctly"
    ],
    "passes": false
  },
  {
    "category": "Integration",
    "description": "Complex nested VGroup animation works",
    "steps": [
      "Create deeply nested VGroup structure",
      "Apply transformations at multiple levels",
      "Animate the root VGroup",
      "Verify all descendants animate correctly"
    ],
    "passes": false
  },
  {
    "category": "Integration",
    "description": "Graph with layout animation works",
    "steps": [
      "Create Graph with nodes and edges",
      "Apply layout algorithm",
      "Animate layout transition",
      "Verify smooth node repositioning"
    ],
    "passes": false
  },
  {
    "category": "Integration",
    "description": "Text with per-glyph animation works",
    "steps": [
      "Create Text with multiple characters",
      "Apply staggered animation to each glyph",
      "Render animation",
      "Verify each glyph animates with correct timing"
    ],
    "passes": false
  },
  {
    "category": "Integration",
    "description": "Camera animation with scene content works",
    "steps": [
      "Create Scene with Mobjects",
      "Animate Camera pan, zoom, rotation",
      "Render animation",
      "Verify Camera movements are smooth"
    ],
    "passes": false
  },
  {
    "category": "Scene",
    "description": "Scene produces output in requested format on completion",
    "steps": [
      "Create Scene with animations",
      "Request MP4 output format",
      "Verify Scene completes and produces MP4",
      "Request GIF output format",
      "Verify Scene completes and produces GIF"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - VGroup",
    "description": "VGroup supports keyframes and easing as a whole",
    "steps": [
      "Create VGroup with children",
      "Apply keyframe animation to VGroup",
      "Apply easing to VGroup animation",
      "Verify keyframes affect all children together",
      "Verify easing is applied uniformly to group"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - VGroup",
    "description": "VGroup morphTo maintains relative positions",
    "steps": [
      "Create source VGroup with positioned children",
      "Create target VGroup with different shapes",
      "Apply morphTo animation",
      "Verify children morph collectively",
      "Verify relative positions between children are maintained"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI pos(x, y) sets initial position without animation",
    "steps": [
      "Create Mobject",
      "Call pos(100, 50)",
      "Verify position is immediately set to (100, 50)",
      "Verify no animation is created",
      "Verify method returns this for chaining"
    ],
    "passes": false
  },
  {
    "category": "ProAPI",
    "description": "ProAPI does not force beginner defaults",
    "steps": [
      "Create Animation via ProAPI without specifying duration",
      "Verify no default duration is forced",
      "Create Animation without specifying easing",
      "Verify no default easing is forced",
      "Verify professional user has full control"
    ],
    "passes": false
  },
  {
    "category": "Hybrid API",
    "description": "No API style restrictions for any operation",
    "steps": [
      "Perform fade animation via FluentAPI",
      "Perform same fade animation via ProAPI",
      "Perform move animation via FluentAPI",
      "Perform same move animation via ProAPI",
      "Verify all operations work in both styles"
    ],
    "passes": false
  },
  {
    "category": "Camera",
    "description": "Camera supports smooth transitions between view states",
    "steps": [
      "Create Camera at initial state (position, zoom, rotation)",
      "Define target view state",
      "Animate transition between states",
      "Verify transition is smooth (no jumps)",
      "Verify intermediate states are interpolated correctly"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Graph",
    "description": "Graph structure changes animate smoothly",
    "steps": [
      "Create Graph with initial nodes and edges",
      "Add new node to Graph",
      "Verify new node animates into position",
      "Remove existing node",
      "Verify node animates out smoothly",
      "Add new edge",
      "Verify edge draws smoothly"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Graph",
    "description": "Graph node/edge animations support duration and easing",
    "steps": [
      "Create Graph with nodes and edges",
      "Animate node with custom duration",
      "Verify duration is respected",
      "Animate edge with custom easing",
      "Verify easing is applied",
      "Verify same timeline rules as other Mobjects"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Graph",
    "description": "Graph supports per-element and collective animations",
    "steps": [
      "Create Graph with multiple nodes and edges",
      "Animate single node individually",
      "Verify only that node animates",
      "Animate single edge individually",
      "Verify only that edge animates",
      "Animate all nodes collectively",
      "Verify all nodes animate together"
    ],
    "passes": false
  },
  {
    "category": "Modular Architecture",
    "description": "Clear interfaces are defined between modules",
    "steps": [
      "Verify core module exports defined interfaces",
      "Verify mobjects module exports defined interfaces",
      "Verify animations module exports defined interfaces",
      "Verify timeline module exports defined interfaces",
      "Verify renderer module exports defined interfaces",
      "Verify cli module exports defined interfaces"
    ],
    "passes": false
  },
  {
    "category": "Modular Architecture",
    "description": "Engine can be extended by implementing interfaces",
    "steps": [
      "Create custom VMobject by implementing VMobject interface",
      "Verify custom VMobject works in Scene",
      "Create custom Animation by implementing Animation interface",
      "Verify custom Animation works in Timeline",
      "Verify no internal implementation knowledge required"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI morphTo works correctly",
    "steps": [
      "Create source VMobject (Circle)",
      "Create target VMobject (Rectangle)",
      "Call source.morphTo(target, duration)",
      "Verify method returns this for chaining",
      "Verify morph animation is created"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI draw() works correctly",
    "steps": [
      "Create VMobject with stroke and fill",
      "Call draw(duration)",
      "Verify method returns this for chaining",
      "Verify draw animation is created"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI write() simulates hand-writing",
    "steps": [
      "Create VMobject or Text",
      "Call write(duration)",
      "Verify method returns this for chaining",
      "Verify write animation is created",
      "Verify stroke is drawn progressively"
    ],
    "passes": false
  },
  {
    "category": "FluentAPI",
    "description": "FluentAPI unwrite() simulates erasing",
    "steps": [
      "Create VMobject or Text with visible stroke",
      "Call unwrite(duration)",
      "Verify method returns this for chaining",
      "Verify unwrite animation is created",
      "Verify stroke is removed progressively in reverse"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Text",
    "description": "Text toOutlines() returns raw BezierPaths",
    "steps": [
      "Create Text with content",
      "Call toOutlines()",
      "Verify array of BezierPaths is returned",
      "Verify each glyph has corresponding BezierPath"
    ],
    "passes": false
  },
  {
    "category": "Mobjects - Text",
    "description": "Text applies kerning and spacing from font metrics",
    "steps": [
      "Create Text with characters that have kerning (e.g., 'AV')",
      "Verify kerning is applied between glyphs",
      "Create Text with letterSpacing style",
      "Verify letter spacing is applied"
    ],
    "passes": false
  },
  {
    "category": "Serialization",
    "description": "Serialization preserves BezierPath control points",
    "steps": [
      "Create VMobject with custom BezierPath",
      "Serialize the Scene",
      "Verify JSON contains control points",
      "Deserialize the Scene",
      "Verify BezierPath control points are restored exactly"
    ],
    "passes": false
  },
  {
    "category": "Serialization",
    "description": "Serialization preserves animation timing data",
    "steps": [
      "Create Scene with animations having specific durations and delays",
      "Serialize the Scene",
      "Verify JSON contains timing data",
      "Deserialize the Scene",
      "Verify animation timing is restored exactly"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Corrupt project file error is descriptive",
    "steps": [
      "Create corrupted project file (invalid JSON structure)",
      "Attempt to load the file",
      "Verify descriptive error message is shown",
      "Verify error indicates the corruption issue"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Version mismatch error is handled",
    "steps": [
      "Create project file with incompatible version",
      "Attempt to load the file",
      "Verify VersionMismatch error is thrown",
      "Verify error message explains version incompatibility"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Unsupported format error is clear",
    "steps": [
      "Request rendering with unsupported format",
      "Verify UnsupportedFormat error is thrown",
      "Verify error lists supported formats"
    ],
    "passes": false
  },
  {
    "category": "Error Handling",
    "description": "Encoding error provides details",
    "steps": [
      "Cause video encoding to fail",
      "Verify EncodingError is thrown",
      "Verify error includes encoding failure details"
    ],
    "passes": false
  },
  {
    "category": "Animations - Keyframes",
    "description": "Keyframe conflict error is thrown for duplicates",
    "steps": [
      "Create KeyframeTrack",
      "Add keyframe at time 0",
      "Attempt to add another keyframe at time 0",
      "Verify KeyframeConflict error is thrown"
    ],
    "passes": false
  },
  {
    "category": "Animations - Base",
    "description": "Animation target missing error is thrown",
    "steps": [
      "Create Animation with null target",
      "Verify AnimationTargetMissing error is thrown",
      "Create Animation with undefined target",
      "Verify AnimationTargetMissing error is thrown"
    ],
    "passes": true
  },
  {
    "category": "Mobjects - Base Classes",
    "description": "Invalid Mobject state error is thrown",
    "steps": [
      "Create Mobject",
      "Attempt to set negative opacity",
      "Verify InvalidMobjectState error is thrown",
      "Attempt to set invalid property value",
      "Verify error describes what is invalid"
    ],
    "passes": false
  },
  {
    "category": "Property Testing - Vector2",
    "description": "Vector2 algebraic properties hold for arbitrary inputs",
    "steps": [
      "Property: add is commutative (a + b == b + a)",
      "Property: add is associative ((a + b) + c == a + (b + c))",
      "Property: multiply by 1 is identity (v * 1 == v)",
      "Property: multiply by 0 yields zero vector (v * 0 == ZERO)",
      "Property: normalize produces unit length (|normalize(v)| == 1 for v != ZERO)",
      "Property: dot product is commutative (a.dot(b) == b.dot(a))",
      "Property: length is non-negative (|v| >= 0)",
      "Property: lerp(a, b, 0) == a and lerp(a, b, 1) == b"
    ],
    "passes": true
  },
  {
    "category": "Property Testing - Matrix3x3",
    "description": "Matrix3x3 algebraic properties hold for arbitrary inputs",
    "steps": [
      "Property: identity * M == M and M * identity == M",
      "Property: M * inverse(M) == identity (for invertible M)",
      "Property: (A * B) * C == A * (B * C) (associativity)",
      "Property: translation(0, 0) == identity",
      "Property: rotation(0) == identity",
      "Property: scale(1, 1) == identity",
      "Property: transformPoint preserves origin for identity matrix"
    ],
    "passes": true
  },
  {
    "category": "Property Testing - Color",
    "description": "Color operations preserve expected properties",
    "steps": [
      "Property: fromHex(toHex(c)) == c (round-trip)",
      "Property: lerp(c, c, t) == c for any t",
      "Property: lerp(a, b, 0) == a and lerp(a, b, 1) == b",
      "Property: RGB values are always clamped to [0, 255]",
      "Property: alpha values are always clamped to [0, 1]"
    ],
    "passes": true
  },
  {
    "category": "Property Testing - BezierPath",
    "description": "BezierPath morphing properties hold",
    "steps": [
      "Property: getPointAt(0) == start point",
      "Property: getPointAt(1) == end point",
      "Property: getLength() >= 0 for any path",
      "Property: interpolate(p, p, t) == p for any t",
      "Property: interpolate(p1, p2, 0) endpoints match p1",
      "Property: interpolate(p1, p2, 1) endpoints match p2",
      "Property: matchPoints produces equal point counts"
    ],
    "passes": true
  },
  {
    "category": "Property Testing - Easing",
    "description": "Easing functions satisfy boundary conditions",
    "steps": [
      "Property: all easing functions return 0 at t=0",
      "Property: all easing functions return 1 at t=1",
      "Property: linear easing is identity (linear(t) == t)",
      "Property: easing output is in reasonable range near [0, 1]"
    ],
    "passes": false
  },
  {
    "category": "Property Testing - Mobject",
    "description": "Mobject transformation properties hold",
    "steps": [
      "Property: applying identity matrix does not change state",
      "Property: pos(x, y) correctly updates position to (x, y)",
      "Property: show() sets opacity to 1",
      "Property: hide() sets opacity to 0",
      "Property: scale extraction is positive for positive scale matrices"
    ],
    "passes": true
  },
  {
    "category": "Property Testing - Serialization",
    "description": "Serialization round-trip is lossless for arbitrary data",
    "steps": [
      "Property: deserialize(serialize(scene)) == scene",
      "Property: serialize produces valid JSON for any Scene",
      "Property: double serialization produces identical output"
    ],
    "passes": false
  }
]